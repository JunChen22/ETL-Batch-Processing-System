server:
  port: 8080
  shutdown: graceful

spring:
  application:
    name: etl
  datasource:
    url: jdbc:postgresql://localhost:5433/contentdb
    username: postgres
    password: password
    driverClassName: org.postgresql.Driver
  jpa:
    defer-datasource-initialization: true
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: create
    show-sql: true
  sql:
    init:
      mode: always
      #schema-locations: classpath:/schema.sql if you want to run schema.sql, Hibernate did not
      data-locations: classpath:/data.sql      # default location,classpath, src/main/resources
  redis:
    host: localhost
    port: 6379
  cloud:
    function:   # tells spring which functions to use
      definition: articleMessageProcessor
    stream:
      default-binder: kafka
      default:
        contentType: application/json
      kafka:
        binder:
          brokers: localhost:9092
          replication-factor: 1
      bindings:
        articleMessageProcessor-in-0:
          destination: adminArticle
          group: adminArticleGroup
          consumer:
            partitioned: true
  #       Outgoing message example:
  #        app-article-out-0:
  #          destination: article
  #          producer:
  #            required-groups: auditGroup
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration

management:
  endpoints:
    web:
      exposure:
        include: health
  endpoint:
    health:
      show-details: "ALWAYS"
      probes:
        enabled: true
  health:
    redis:
      enabled: true
    kafka:  # Try this first, fallback to 'binders' if it doesn't work
      enabled: true

---
spring:
  config:
    activate:
      on-profile: docker
  datasource:
    url: jdbc:postgresql://cms-db:5433/contentdb
  cloud:
    stream:
      kafka:
        binder:
          brokers: cms-kafka:9092

server:
  port: 80